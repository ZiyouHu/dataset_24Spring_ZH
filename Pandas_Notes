dataframe.head(#)
dataframe.tail(#)
can save the result as a new data frame
series: the columns in dataframe

Filtering: reduce a data frame to rows that match a criterion.
timeseries['column_name']: to just look at one series.
can do math operations on them
Can also do comparisons: a bunch of booleans 


If the column has a "normal" name, you can just do timeseries.column_name
time_series[a list of T/F (those that do or do not satisfy a condition)]

replace "and" with "&" because "&" is bit operator when typing conditions. Remember to use "()" !!!
for the same reason, use "/".

dataframe.sort_values("column_name_to_sort_by")

If you are looking at a single timeseries, use timeseries.order().

not_null_df = df[df.timeseries.notnull()]
null_df = df[df.timeseries.isnull()]

filtering that has to do with strings:
df.series_name.str.startswith("blah")

how many times each value appears: series.value_counts()

For index with values, can ask panda to plot: .plot()



How to sort by df's index?

.sort_index()

df.plot(x = time_series, y = time_series, kind="scatter")

df[[series_name, series_name, ...]]  : will only display these columns


%%time: runs the noraml operation and reports how long the operation takes.

df.set_index(['series_name', 'series_name']): replace the line number of the file with the column. We can do .sort_index()

After indexing, df.loc[key]: basically a python dictionary

We can pass df.loc[key1, key2]

Toss it back: .reset_index([key1, key2])

df.groupby(['series_name', 'series_name', 'series_name'])


df.plot(ylim=0)

.size()
.min()
.max()
.mean()


We can even create a series,



df.unstack(): column to row

df.stack(): does the reverse

df.fillna()

df has 2 indices; the 2 dimensions should be maintained.

merge()

pivot()
dt: date and time


DataFrame: a data structure that organizes data into a 2-dimensional table of rows and columns, much like a spreadsheet. 2D array

series: 1D array

merge(): Combine two Series or DataFrame objects with SQL-style joining
- one-to-one: joining 2 df objects on their indexes which must contain unique values
- many-to-one: joining a unique index to one or more columns in a different df
- many-to-many: joining columns on columns



pandas.pivot(index, columns, values) function produces a pivot table based on 3 columns of the DataFrame. Uses unique values from the index/columns and fills them with values.
