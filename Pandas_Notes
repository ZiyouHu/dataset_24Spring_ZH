dataframe.head(#)
dataframe.tail(#)
can save the result as a new data frame
series: the columns in dataframe

Filtering: reduce a data frame to rows that match a criterion.
timeseries['column_name']: to just look at one series.
can do math operations on them
Can also do comparisons: a bunch of booleans 


If the column has a "normal" name, you can just do timeseries.column_name
time_series[a list of T/F (those that do or do not satisfy a condition)]

replace "and" with "&" because "&" is bit operator when typing conditions. Remember to use "()" !!!
for the same reason, use "/".

dataframe.sort_values("column_name_to_sort_by")

If you are looking at a single timeseries, use timeseries.order().

not_null_df = df[df.timeseries.notnull()]
null_df = df[df.timeseries.isnull()]

filtering that has to do with strings:
df.series_name.str.startswith("blah")

how many times each value appears: series.value_counts()

For index with values, can ask panda to plot: .plot()



How to sort by df's index?

.sort_index()

df.plot(x = time_series, y = time_series, kind="scatter")

df[[series_name, series_name, ...]]  : will only display these columns


%%time: runs the noraml operation and reports how long the operation takes.

df.set_index(['series_name', 'series_name']): replace the line number of the file with the column. We can do .sort_index()

After indexing, df.loc[key]: basically a python dictionary

We can pass df.loc[key1, key2]

Toss it back: .reset_index([key1, key2])
